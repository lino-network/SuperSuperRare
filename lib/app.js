const express = require('express')
const { createBundleRenderer } = require('vue-server-renderer')
const fs = require('fs')
const favicon = require('serve-favicon')
const LRU = require('lru-cache')
const compression = require('compression')
var os = require('os');
const getCookieServer = require('./cookie').getCookieServer;
const config = require('./config')

const DEFAULT_OPTIONS = {
  prodOnly: false,
}

function readHttpServiceAddr(serviceName, defaultVal) {
  let hostEnvKey = "LINOAPP_" + serviceName + "_SERVICE_HOST";
  let portEnvKey = "LINOAPP_" + serviceName + "_SERVICE_PORT";

  let host = process.env[hostEnvKey];
  if (host == undefined || host == "") {
      return defaultVal;
  }

  let port = process.env[portEnvKey];
  if (port == undefined || port == "") {
      return defaultVal;
  }
  if ((host + ":" + port).includes('http')) {
    return host + ":" + port;
  } else {
    return 'http://' + host + ":" + port;
  }
}

function getCacheKey(req) {
  let darkMode = getCookieServer('darkMode', req.headers.cookie);
  if (darkMode !== 'false') {
    darkMode = '';
  }
  let lang = getCookieServer('langCode', req.headers.cookie) || req.headers['cloudfront-viewer-country'] || ''
  return req.url + darkMode + lang
}

module.exports = (app, options) => {
  // console.log('server side VUE_APP_GRAPHQL_HTTP: ', process.env.VUE_APP_GRAPHQL_HTTP);
  global.backendURL = process.env.VUE_APP_GRAPHIGO_HTTP;
  options = Object.assign({}, DEFAULT_OPTIONS, options)

  const isProd = process.env.NODE_ENV === 'production'

  if (options.prodOnly && !isProd) return

  const templatePath = config.templatePath

  try {
    // Vue bundle renderer
    let renderer
    // In development: wait for webpack compilation
    // when receiving a SSR request
    let readyPromise

    const directives = config.directives
    
    const cache = LRU({
      max: 1000,
      maxAge: 20000,
    })

    const isCacheable = req => {
      // implement logic to check if the request is user-specific.
      // only non-user-specific pages are cache-able
      if (req.url.startsWith('/cashin/') || req.url == '/dashboard' || req.url == '/following' || req.url == '/paymentfailed' || req.url == '/paymentsuccess' || req.url == '/settings' || req.url == '/upload') {
        return false;
      }
      return true;
    }

    const defaultRendererOptions = {
      cache: LRU({
        max: 1000,
        maxAge: 1000 * 60 * 15,
      }),
      runInNewContext: false,
      inject: false,
      directives,
    }

    if (isProd) {
      // In production: create server renderer using template and built server bundle.
      // The server bundle is generated by vue-ssr-webpack-plugin.
      const template = fs.readFileSync(templatePath, 'utf-8')
      const serverBundle = require(`${config.distPath}/vue-ssr-server-bundle.json`)
      // The client manifests are optional, but it allows the renderer
      // to automatically infer preload/prefetch links and directly add <script>
      // tags for any async chunks used during render, avoiding waterfall requests.
      const clientManifest = require(`${config.distPath}/vue-ssr-client-manifest.json`)
      renderer = createBundleRenderer(serverBundle, {
        ...defaultRendererOptions,
        template,
        clientManifest,
        shouldPrefetch: (file, type) => {
          // type is inferred based on the file extension.
          // https://fetch.spec.whatwg.org/#concept-request-destination
          if (file.includes('video') || file.includes('cropper') || file.includes('infiniteload') || file.includes('common') || file.includes('lang')) {
            return false;
          }
          return true;
        }
      })
    } else {
      // In development: setup the dev server with watch and hot-reload,
      // and create a new renderer on bundle / index template update.
      const { setupDevServer } = require('./dev-server')
      readyPromise = setupDevServer({
        server: app,
        templatePath,
        onUpdate: ({ serverBundle }, options) => {
          // Re-create the bundle renderer
          renderer = createBundleRenderer(serverBundle, {
            ...defaultRendererOptions,
            ...options,
          })
        },
      })
    }

    // Serve static files
    const serve = (filePath, cache) => express.static(filePath, {
      maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0,
      index: false,
    })

    // Serve static files
    app.enable('etag') // use strong etags
    app.use(compression({ threshold: 0 }))
    if (isProd) {
      app.use(favicon('./dist/favicon.ico'))
    } else {
      app.use(favicon('./public/favicon.ico'))
    }
    if (config.api.hasPlugin('pwa')) {
      app.use('/service-worker.js', serve(config.serviceWorkerPath, true))
    }
    const serveStaticFiles = serve(config.distPath, true)
    app.use((req, res, next) => {
      // res.setHeader("Cache-Control", "public")
      // res.setHeader("Expires", new Date(Date.now() + 86400000).toUTCString());
      if (/index\.html/g.test(req.path)) {
        next()
      } else {
        serveStaticFiles(req, res, next)
      }
    })

    if (config.extendServer) {
      config.extendServer(app)
    }

    // Render the Vue app using the bundle renderer
    const renderApp = (req, res) => {
      res.setHeader('Content-Type', 'text/html')
      res.setHeader('Cache-Control', 'public, max-age=0, s-maxage=20')
      // res.setHeader("Expires", new Date(Date.now() + 20000).toUTCString());
      res.setHeader('X-Frame-Options', 'DENY')
      const context = {
        req,
        url: req.url,
        title: config.defaultTitle,
        httpCode: 200,
      }
      renderer.renderToString(context, (err, html) => {
        if (err) {
          console.error(`error during render url : ${req.url}`)
          console.error(err)

          // Render Error Page
          let errorHtml = config.error500Html
            ? fs.readFileSync(config.error500Html, 'utf-8') 
            : '500 | Internal Server Error'

          if (!isProd) {
            const errorMessage = `<pre>${err.stack}</pre>`
            config.error500Html
              ? errorHtml = errorHtml.replace('<!--server-error-msg-->', errorMessage)
              : errorHtml += errorMessage
          }

          res.status(500).send(errorHtml)
        } else {
          const cacheable = isCacheable(req)
          if (cacheable) {
            cache.set(getCacheKey(req), html)
          }
          // console.log('from express');
          res.status(context.httpCode).send(html)
        }
      })
    }

    // Process SSR requests
    let ssr
    if (isProd) {
      ssr = renderApp
    } else {
      // In development: wait for webpack compilation
      // when receiving a SSR request
      ssr = (req, res) => {
        readyPromise.then(() => renderApp(req, res)).catch(console.error)
      }
    }

    app.get('/api/setDarkMode', function(req, res) {
      res.cookie('darkMode', req.query.darkMode, { maxAge: 2592000000, httpOnly: true });
      res.send(200);
    })

    setInterval(() => {
      cache.prune()
    }, 60000)

    app.get('*', (req, res, next) => {
      // NING: unable to use useragent because it must be forwarded through cloudfront
      if ((req.headers['cloudfront-is-mobile-viewer'] == 'true') && (req.path == '/' )) {
        res.setHeader('Cache-Control', 'public, max-age=0, s-maxage=20')
        return res.redirect('/m/home/' + req.url.slice(1));
      } else if ((req.headers['cloudfront-is-mobile-viewer'] == 'false') && (req.path == '/m/home/')) {
        res.setHeader('Cache-Control', 'public, max-age=0, s-maxage=20')
        return res.redirect('/' + req.url.slice(8));
      }
      console.log(os.freemem());
      global.ua = req.useragent;
      if (config.skipRequests(req)) {
        return next()
      }
      
      const cacheable = isCacheable(req)
      if (cacheable) {
        const hit = cache.get(getCacheKey(req))
        if (hit) {
          res.setHeader('Content-Type', 'text/html')
          res.setHeader('Cache-Control', 'public, max-age=0, s-maxage=20')
          res.setHeader('X-Frame-Options', 'DENY')
          return res.status(200).send(hit)
        }
      }
      ssr(req, res)
    })
    return readyPromise
  } catch (e) {
    console.log(e)
    return e;
  }
}
